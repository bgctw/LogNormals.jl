var documenterSearchIndex = {"docs":
[{"location":"lognormalprops.html#Properties-of-the-LogNormal-distribution","page":"LogNormal properties","title":"Properties of the LogNormal distribution","text":"","category":"section"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"The LogNormal distribution can be characterized by the exponent of its parameters:","category":"page"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"exp(μ): the median\nexp(σ): the multiplicative standard deviation sigma^*.","category":"page"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"Function σstar returns the multiplicative standard deviation.","category":"page"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"A distribution can be specified by taking the log of median and sigma^*","category":"page"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"d = LogNormal(log(2), log(1.2))\nσstar(d) == 1.2","category":"page"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"Alternatively the distribution can be specified by its mean and sigma^* using type Σstar","category":"page"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"d = fit(LogNormal, 2, Σstar(1.2))\n(mean(d), σstar(d)) == (2, 1.2)","category":"page"},{"location":"lognormalprops.html#Detailed-API","page":"LogNormal properties","title":"Detailed API","text":"","category":"section"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"LogNormals.σstar(::LogNormal)","category":"page"},{"location":"lognormalprops.html#LogNormals.σstar-Tuple{LogNormal}","page":"LogNormal properties","title":"LogNormals.σstar","text":"σstar(d)\n\nGet the multiplicative standard deviation of LogNormal distribution d.\n\nArguments\n\nd: The type of distribution to fit\n\nExamples\n\nd = LogNormal(2,log(1.2))\nσstar(d) == 1.2\n\n\n\n\n\n","category":"method"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"StatsBase.fit(::Type{LogNormal}, ::Any, ::Σstar) ","category":"page"},{"location":"lognormalprops.html#StatsBase.fit-Tuple{Type{LogNormal}, Any, Σstar}","page":"LogNormal properties","title":"StatsBase.fit","text":"fit(D, mean, σstar)\n\nFit a statistical distribution of type D to mean and multiplicative  standard deviation.\n\nArguments\n\nD: The type of distribution to fit\nmean: The moments of the distribution\nσstar::Σstar: The multiplicative standard deviation\n\nSee also σstar, Σstar. \n\nExamples\n\nd = fit(LogNormal, 2, Σstar(1.1));\n(mean(d), σstar(d)) == (2, 1.1)\n\n\n\n\n\n","category":"method"},{"location":"lognormalprops.html","page":"LogNormal properties","title":"LogNormal properties","text":"LogNormals.Σstar","category":"page"},{"location":"lognormalprops.html#LogNormals.Σstar","page":"LogNormal properties","title":"LogNormals.Σstar","text":"Σstar\n\nRepresent the multiplicative standard deviation of a LogNormal distribution.\n\nSupports dispatch of fit. Invoking the type as a function returns its single value.\n\nExamples\n\na = Σstar(4.2)\na() == 4.2\n\n\n\n\n\n","category":"type"},{"location":"semcor.html#Standard-error-of-the-mean-of-correlated-series","page":"sem correlated","title":"Standard error of the mean of correlated series","text":"","category":"section"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"The standard error of the mean of a series with positive autocorrelation is larger than  for an uncorrelated series, because the variance  includes positive covariance terms  in addition to the variance of each record.","category":"page"},{"location":"semcor.html#Effective-number-of-observations","page":"sem correlated","title":"Effective number of observations","text":"","category":"section"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"For uncorrelated series, the variance of the mean decreases by the number of records compared to the  variance of a single record.","category":"page"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"Var(barx) = Var(x) over n","category":"page"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"For correlated series, the effective number of observations is defined as to give the same scaling.","category":"page"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"Var(barx) = Var(x) over n_eff","category":"page"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"There are only n_eff number of effective obserservations in the series.","category":"page"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"effective_n_cor","category":"page"},{"location":"semcor.html#LogNormals.effective_n_cor","page":"sem correlated","title":"LogNormals.effective_n_cor","text":"effective_n_cor(x, ms::MissingStrategy=PassMissing()) \neffective_n_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())\n\nCompute the number of effective observations for an autocorrelated series.\n\nArguments\n\nx: An iterator of a series of observations.\nms: MissingStrategy: If not given defaults to PassMissing.  Set to ExactMissing() to consciouly handle missing value in x.\nacf: AutocorrelationFunction starting from lag 0.   If not given, defaults to autocor(x, ms) \n\nThe formula in Zieba has been extended for missing values:\n\nn_eff = fracn_F1+2 over n_F sum_k=1^min(n-1n_k) (n-k-m_k) rho_k\n\nwhere n is the number of total records, n_F is the number of  finite records, n_k is the nummber of components in the  used autocorrelation function (n-1 if not estimated from the data) ,rho_k is the correlation, and  m_k is the number of pairs that contain a missing value for lag k.\n\nDetails\n\nMissing values are not handled by default, i.e. the number of effective observations is missing if ther any missings in x.  The recommended way is using ExactMissing().  Alternatively, se to  SkipMissing() to speed up computation  (by internally omitting count_forlags missing pairs)  at the cost of a positively biased result with increasing bias with the number of missings.  The latter leads to a subsequent underestimated uncertainty of the sum or the mean.\n\nExamples\n\nusing Distributions, DistributionVectors, Missings, MissingStrategies, LinearAlgebra\nacf0 = [1,0.4,0.1]\nSigma = cormatrix_for_acf(100, acf0);\n# 100 random variables each Normal(1,1)\ndmn = MvNormal(ones(100), Symmetric(Sigma));\nx = allowmissing(rand(dmn));    \nx[11:20] .= missing\nneff = effective_n_cor(x, acf0, ExactMissing())\nneff < 90\nneff_biased = effective_n_cor(x, acf0, SkipMissing())\nneff_biased > neff\n\n\n\n\n\neffective_n_cor(x, ms::MissingStrategy=PassMissing()) \neffective_n_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())\n\nCompute the number of effective observations for an autocorrelated series.\n\nArguments\n\nx: An iterator of a series of observations.\nms: MissingStrategy: If not given defaults to PassMissing.  Set to ExactMissing() to consciouly handle missing value in x.\nacf: AutocorrelationFunction starting from lag 0.   If not given, defaults to autocor(x, ms) \n\nThe formula in Zieba has been extended for missing values:\n\nn_eff = fracn_F1+2 over n_F sum_k=1^min(n-1n_k) (n-k-m_k) rho_k\n\nwhere n is the number of total records, n_F is the number of  finite records, n_k is the nummber of components in the  used autocorrelation function (n-1 if not estimated from the data) ,rho_k is the correlation, and  m_k is the number of pairs that contain a missing value for lag k.\n\nDetails\n\nMissing values are not handled by default, i.e. the number of effective observations is missing if ther any missings in x.  The recommended way is using ExactMissing().  Alternatively, se to  SkipMissing() to speed up computation  (by internally omitting count_forlags missing pairs)  at the cost of a positively biased result with increasing bias with the number of missings.  The latter leads to a subsequent underestimated uncertainty of the sum or the mean.\n\nExamples\n\nusing Distributions, DistributionVectors, Missings, MissingStrategies, LinearAlgebra\nacf0 = [1,0.4,0.1]\nSigma = cormatrix_for_acf(100, acf0);\n# 100 random variables each Normal(1,1)\ndmn = MvNormal(ones(100), Symmetric(Sigma));\nx = allowmissing(rand(dmn));    \nx[11:20] .= missing\nneff = effective_n_cor(x, acf0, ExactMissing())\nneff < 90\nneff_biased = effective_n_cor(x, acf0, SkipMissing())\nneff_biased > neff\n\n\n\n\n\neffective_n_cor(x, ms::MissingStrategy=PassMissing()) \neffective_n_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())\n\nCompute the number of effective observations for an autocorrelated series.\n\nArguments\n\nx: An iterator of a series of observations.\nms: MissingStrategy: If not given defaults to PassMissing.  Set to ExactMissing() to consciouly handle missing value in x.\nacf: AutocorrelationFunction starting from lag 0.   If not given, defaults to autocor(x, ms) \n\nThe formula in Zieba has been extended for missing values:\n\nn_eff = fracn_F1+2 over n_F sum_k=1^min(n-1n_k) (n-k-m_k) rho_k\n\nwhere n is the number of total records, n_F is the number of  finite records, n_k is the nummber of components in the  used autocorrelation function (n-1 if not estimated from the data) ,rho_k is the correlation, and  m_k is the number of pairs that contain a missing value for lag k.\n\nDetails\n\nMissing values are not handled by default, i.e. the number of effective observations is missing if ther any missings in x.  The recommended way is using ExactMissing().  Alternatively, se to  SkipMissing() to speed up computation  (by internally omitting count_forlags missing pairs)  at the cost of a positively biased result with increasing bias with the number of missings.  The latter leads to a subsequent underestimated uncertainty of the sum or the mean.\n\nExamples\n\nusing Distributions, DistributionVectors, Missings, MissingStrategies, LinearAlgebra\nacf0 = [1,0.4,0.1]\nSigma = cormatrix_for_acf(100, acf0);\n# 100 random variables each Normal(1,1)\ndmn = MvNormal(ones(100), Symmetric(Sigma));\nx = allowmissing(rand(dmn));    \nx[11:20] .= missing\nneff = effective_n_cor(x, acf0, ExactMissing())\nneff < 90\nneff_biased = effective_n_cor(x, acf0, SkipMissing())\nneff_biased > neff\n\n\n\n\n\n","category":"function"},{"location":"semcor.html#Standard-error-of-the-mean-of-a-correlated-series","page":"sem correlated","title":"Standard error of the mean of a correlated series","text":"","category":"section"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"sem_cor","category":"page"},{"location":"semcor.html#LogNormals.sem_cor","page":"sem correlated","title":"LogNormals.sem_cor","text":"sem_cor(x, ms::MissingStrategy=PassMissing())\nsem_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())\n\nEstimate the standard error of the mean of an autocorrelated series: Var(barx) = Var(x) over n_eff.    \n\nArguments\n\nx: An iterator of a series of observations\nacf: AutocorrelationFunction starting from lag 0. \nms: MissingStrategy passed to effective_n_cor. Value of SkipMissing() speeds up computation compared to ExactMissing(), but leads to a negatively biased result with absolute value of the bias  increasing with the number of missings.\n\nOptional Arguments\n\nneff: may provide a precomputed number of observations for efficiency.\n\n\n\n\n\nsem_cor(x, ms::MissingStrategy=PassMissing())\nsem_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())\n\nEstimate the standard error of the mean of an autocorrelated series: Var(barx) = Var(x) over n_eff.    \n\nArguments\n\nx: An iterator of a series of observations\nacf: AutocorrelationFunction starting from lag 0. \nms: MissingStrategy passed to effective_n_cor. Value of SkipMissing() speeds up computation compared to ExactMissing(), but leads to a negatively biased result with absolute value of the bias  increasing with the number of missings.\n\nOptional Arguments\n\nneff: may provide a precomputed number of observations for efficiency.\n\n\n\n\n\n","category":"function"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"The default estiamtes the empirical autocorrelation from the given series.  If possible, use a more precise estimate from longer series. For example when computing the daily means of an hourly time series, estimate the  empirical autocorrelation from monthly or annual series and provide it to the daily applications of sem_cor using argument acfe.","category":"page"},{"location":"semcor.html#Variance-of-a-correlated-series","page":"sem correlated","title":"Variance of a correlated series","text":"","category":"section"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"var_cor","category":"page"},{"location":"semcor.html#LogNormals.var_cor","page":"sem correlated","title":"LogNormals.var_cor","text":"var_cor(x, ms::MissingStrategy=PassMissing())\nvar_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())\n\nEstimate the variance for an autocorrelated series.\n\nZieba 2011 provide the following formula:\n\nVar(x) = fracn_effn (n_eff-1) sum left( x_i - barx right)^2 \n= (n-1) n_eff over n (n_eff-1) Var_uncor(x)\n\nArguments\n\nx: An iterator of a series of observations\nacf: AutocorrelationFunction starting from lag 0. \nms: MissingStrategy passed to effective_n_cor. Value of SkipMissing() speeds up computation compared to ExactMissing(), but leads to a negatively biased result with absolute value of the bias  increasing with the number of missings.\n\nOptional Arguments\n\nneff: may provide a precomputed number of observations for efficiency.\n\n\n\n\n\nvar_cor(x, ms::MissingStrategy=PassMissing())\nvar_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())\n\nEstimate the variance for an autocorrelated series.\n\nZieba 2011 provide the following formula:\n\nVar(x) = fracn_effn (n_eff-1) sum left( x_i - barx right)^2 \n= (n-1) n_eff over n (n_eff-1) Var_uncor(x)\n\nArguments\n\nx: An iterator of a series of observations\nacf: AutocorrelationFunction starting from lag 0. \nms: MissingStrategy passed to effective_n_cor. Value of SkipMissing() speeds up computation compared to ExactMissing(), but leads to a negatively biased result with absolute value of the bias  increasing with the number of missings.\n\nOptional Arguments\n\nneff: may provide a precomputed number of observations for efficiency.\n\n\n\n\n\n","category":"function"},{"location":"semcor.html#Effective-autocorrelation-function","page":"sem correlated","title":"Effective autocorrelation function","text":"","category":"section"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"autocor_effective","category":"page"},{"location":"semcor.html#LogNormals.autocor_effective","page":"sem correlated","title":"LogNormals.autocor_effective","text":"autocor_effective(x, ms::MissingStrategy=PassMissing())\nautocor_effective(x, acf)\n\nEstimate the effective autocorrelation function for series x.\n\nArguments\n\nx: An iterator of a series of observations\nms: MissingStrategy passed to autocor\nacf: AutocorrelationFunction starting from lag 0\n\nNotes\n\nThe effect autocorrelation function   are the first coefficients of the autocorrelation function up to  before the first negative coefficient. \nAccording to Zieba 2011 using this effective version rather the full version when estimating the autocorrelationfunction from the data yields better result for the standard error of the mean (sem_cor).\nOptional argument acf allows the caller to provide a precomputed estimate of autocorrelation function (see autocor).\n\n\n\n\n\nautocor_effective(x, ms::MissingStrategy=PassMissing())\nautocor_effective(x, acf)\n\nEstimate the effective autocorrelation function for series x.\n\nArguments\n\nx: An iterator of a series of observations\nms: MissingStrategy passed to autocor\nacf: AutocorrelationFunction starting from lag 0\n\nNotes\n\nThe effect autocorrelation function   are the first coefficients of the autocorrelation function up to  before the first negative coefficient. \nAccording to Zieba 2011 using this effective version rather the full version when estimating the autocorrelationfunction from the data yields better result for the standard error of the mean (sem_cor).\nOptional argument acf allows the caller to provide a precomputed estimate of autocorrelation function (see autocor).\n\n\n\n\n\n","category":"function"},{"location":"semcor.html#Autocorrelation-of-a-series-with-missing-values","page":"sem correlated","title":"Autocorrelation of a series with missing values","text":"","category":"section"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"StatsBase.autocor","category":"page"},{"location":"semcor.html#StatsBase.autocor","page":"sem correlated","title":"StatsBase.autocor","text":"autocor(x::AbstractVector{x::<:Union{Missing,Real}, ms::MissingStrategy=PassMissing(); \n    dmean::Bool=true}\nautocor(x::AbstractVector{x::<:Union{Missing,Real}, lags, ms::MissingStrategy=PassMissing(); \n    dmean::Bool=true}\nautocor(x::AbstractMatrix{x::<:Union{Missing,Real}, ms::MissingStrategy=PassMissing(); \n    dmean::Bool=true}\nautocor(x::AbstractMatrix{x::<:Union{Missing,Real}, lags, ms::MissingStrategy=PassMissing(); \n    dmean::Bool=true}\n\nEstimate the autocorrelation function accounting for missing values.\n\nArguments\n\nx: series or matrix with series in columns, which may contain missing values\nlags: Integer vector of the lags for which correlation should be computed\nms: MissingStrategy. Defaults to PassMissing. Set to ExactMissing() to   divide the sum  in the formula of the exepected value in the formula for the correlation  at lag k by n - nmissing instead of n,   where nimissing is the number of records where there is a missing either  in the original vector or its lagged version (see count_forlags).\ndeman: if false, assume mean(x)==0.\n\nIf the missing strategy is set to SkipMissing() then the computation is faster,  but it is more strongly biased low with increasing number of missings.  Note that StatsBase.autocor uses devision by n instead of 'n-k', the true length of the vectors correlated at lag k resulting in  low-biased correlations of higher lags for numerical stability reasons.\n\n\n\n\n\n","category":"function"},{"location":"semcor.html","page":"sem correlated","title":"sem correlated","text":"count_forlags","category":"page"},{"location":"semcor.html#LogNormals.count_forlags","page":"sem correlated","title":"LogNormals.count_forlags","text":"count_forlags(pred, x, lags)\ncount_forlag(pred, x, k::Integer)\n\nCount the number of pairs for lag k which fulfil a predicate.\n\nArguments\n\npred::Function(x_i,x_iplusk)::Bool: The predicate to be applied to each pair \nx: The series whose lags are inspected.\nlags: An iterator of Integer lag sizes\nk: A single lag.\n\nCommon case is to compute the number of missings for the autocorrelation: with predicate missinginpair(x,y) = ismissing(x) || ismissing(y).\n\n\n\n\n\n","category":"function"},{"location":"fitstats.html#Distribution-Fitting-to-aggregate-statistics","page":"Fit to statistic","title":"Distribution Fitting to aggregate statistics","text":"","category":"section"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"This package provides method to fit a distribution to a given set of aggregate statistics.","category":"page"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"DocTestSetup = :(using Statistics,Distributions,LogNormals)","category":"page"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"# to specified moments\nd = fit(LogNormal, Moments(3.0,4.0))\n(mean(d), var(d)) .≈ (3.0, 4.0)\n\n# to mean and upper quantile point\nd = fit(LogNormal, 3, @qp_uu(8))\n(mean(d), quantile(d, 0.975)) .≈ (3.0, 8.0)\n\n# to mode and upper quantile point\nd = fit(LogNormal, 3, @qp_uu(8), Val(:mode))\n(mode(d), quantile(d, 0.975)) .≈ (3.0, 8.0)\n\n# to two quantiles, i.e confidence range\nd = fit(LogNormal, @qp_ll(1.0), @qp_uu(8))\n(quantile(d, 0.025), quantile(d, 0.975)) .≈ (1.0, 8.0)\n\n# approximate a different distribution by matching moments\ndn = Normal(3,2)\nd = fit(LogNormal, moments(dn))\n(mean(d), var(d)) .≈ (3.0, 4.0)","category":"page"},{"location":"fitstats.html#Fit-to-statistical-moments","page":"Fit to statistic","title":"Fit to statistical moments","text":"","category":"section"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"StatsBase.fit(::Type{D}, ::AbstractMoments) where {D<:Distribution}","category":"page"},{"location":"fitstats.html#StatsBase.fit-Union{Tuple{D}, Tuple{Type{D}, AbstractMoments}} where D<:Distribution","page":"Fit to statistic","title":"StatsBase.fit","text":"fit(D, m)\n\nFit a statistical distribution of type D to given moments m.\n\nArguments\n\nD: The type of distribution to fit\nm: The moments of the distribution\n\nNotes\n\nThis can be used to approximate one distribution by another.\n\nSee also AbstractMoments, moments. \n\nExamples\n\nd = fit(LogNormal, Moments(3.2,4.6));\n(mean(d), var(d)) .≈ (3.2,4.6)\n\nd = fit(LogNormal, moments(Normal(3,1.2)));\n(mean(d), std(d)) .≈ (3,1.2)\n\nplot(d); lines(!Normal(3,1.2))\n\n\n\n\n\n","category":"method"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"moments(d::Distribution, ::Val{N} = Val(2)) where N ","category":"page"},{"location":"fitstats.html#LogNormals.moments-Union{Tuple{Distribution}, Tuple{N}, Tuple{Distribution, Val{N}}} where N","page":"Fit to statistic","title":"LogNormals.moments","text":"moments(D, ::Val{N} = Val(2))\n\nGet the first N moments of a distribution.\n\nSee also type AbstractMoments.\n\nExamples\n\nmoments(LogNormal(), Val(4))  # first four moments \nmoments(Normal())  # mean and variance\n\n\n\n\n\n","category":"method"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"The syntax Moments(mean,var) produces an object of type Moments <: AbstractMoments.","category":"page"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":" AbstractMoments{N}","category":"page"},{"location":"fitstats.html#LogNormals.AbstractMoments","page":"Fit to statistic","title":"LogNormals.AbstractMoments","text":"AbstractMoments{N}\n\nA representation of statistical moments of a distribution\n\nThe following functions are supported\n\nn_moments(m): get the number of recorded moments\n\nThe following getters return a single moment or  throw an error if the moment has not been recorded\n\nmean(m): get the mean\nvar(m): get the variance\nskewness(m): get the variance\nkurtosis(m): get the variance\ngetindex(m,i): get the ith moment, i.e. indexing m[i]\n\nThe basic implementation Moments is immutable and convert(AbstractArray, m::Moments) returns an SArray{N,T}.\n\nExamples\n\nm = Moments(1,0.2);\nn_moments(m) == 2\nvar(m) == m[2]\n\nkurtosis(m) # throws error because its above 2nd moment\n\n\n\n\n\n","category":"type"},{"location":"fitstats.html#Fit-to-several-quantile-points","page":"Fit to statistic","title":"Fit to several quantile points","text":"","category":"section"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"StatsBase.fit(::Type{D}, ::QuantilePoint, ::QuantilePoint) where {D<:Distribution}","category":"page"},{"location":"fitstats.html#StatsBase.fit-Union{Tuple{D}, Tuple{Type{D}, QuantilePoint, QuantilePoint}} where D<:Distribution","page":"Fit to statistic","title":"StatsBase.fit","text":"fit(D, lower, upper)\n\nFit a statistical distribution to a set of quantiles \n\nArguments\n\nD: The type of the distribution to fit\nlower:  lower QuantilePoint (p,q)\nupper:  upper QuantilePoint (p,q)\n\nNotes\n\nSeveral macros help to construct QuantilePoints\n\n@qp(q,p)    quantile at specified p: QuantilePoint(q,p)\n@qp_ll(q0_025)  quantile at very low p: QuantilePoint(q0_025,0.025) \n@qp_l(q0_05)    quantile at low p: QuantilePoint(q0_05,0.05) \n@qp_m(median)   quantile at median: QuantilePoint(median,0.5) \n@qp_u(q0_95)    quantile at high p: QuantilePoint(q0_95,0.95)  \n@qp_uu(q0_975)  quantile at very high p: QuantilePoint(q0_975,0.975) \n\nExamples\n\nd = fit(LogNormal, @qp_m(3), @qp_uu(5));\nquantile.(d, [0.5, 0.975]) ≈ [3,5]\n\n\n\n\n\n","category":"method"},{"location":"fitstats.html#Fit-to-mean,mode,median-and-a-quantile-point","page":"Fit to statistic","title":"Fit to mean,mode,median and a quantile point","text":"","category":"section"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"StatsBase.fit(::Type{D}, ::Any, ::QuantilePoint, ::Val{stats} = Val(:mean)) where {D<:Distribution, stats}","category":"page"},{"location":"fitstats.html#StatsBase.fit-Union{Tuple{stats}, Tuple{D}, Tuple{Type{D}, Any, QuantilePoint}, Tuple{Type{D}, Any, QuantilePoint, Val{stats}}} where {D<:Distribution, stats}","page":"Fit to statistic","title":"StatsBase.fit","text":"fit(D, val, qp, ::Val{stats} = Val(:mean))\n\nFit a statistical distribution to a quantile and given statistics\n\nArguments\n\nD: The type of distribution to fit\nval: The value of statistics\nqp: QuantilePoint(q,p)\nstats Which statistics to fit: defaults to Val(:mean).   Alternatives are: Val(:mode), Val(:median)\n\nExamples\n\nd = fit(LogNormal, 5, @qp_uu(14));\n(mean(d),quantile(d, 0.975)) .≈ (5,14)\n\nd = fit(LogNormal, 5, @qp_uu(14), Val(:mode));\n(mode(d),quantile(d, 0.975)) .≈ (5,14)\n\n\n\n\n\n","category":"method"},{"location":"fitstats.html#Implementing-support-for-another-distribution","page":"Fit to statistic","title":"Implementing support for another distribution","text":"","category":"section"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"In order to use the fitting framework for a distribution MyDist, one needs to implement the following four methods.","category":"page"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"StatsBase.fit(::Type{MyDist}, m::AbstractMoments)\n\nfit_mean_quantile(::Type{MyDist}, mean, qp::QuantilePoint)\n\nfit_mode_quantile(::Type{MyDist}, mode, qp::QuantilePoint)\n\nStatsBase.fit(::Type{MyDist}, lower::QuantilePoint, upper::QuantilePoint)","category":"page"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"The default method for fit with stats = :median already works based on the methods for two quantile points. If the general method on two quantile points cannot be specified, one can alternatively implement method:","category":"page"},{"location":"fitstats.html","page":"Fit to statistic","title":"Fit to statistic","text":"fit_median_quantile(::Type{MyDist}, median, qp::QuantilePoint)","category":"page"},{"location":"index.html#LogNormals.jl","page":"Home","title":"LogNormals.jl","text":"","category":"section"},{"location":"index.html#LogNormals-Package","page":"Home","title":"LogNormals Package","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":" LogNormals","category":"page"},{"location":"index.html#LogNormals","page":"Home","title":"LogNormals","text":"Tools that help using the LogNormal distribution.\n\nFitting to various aggregate statistics\nSum of correlated lognormal random variables\n\n\n\n\n\n","category":"module"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"lognormalprops.md\", \"fitstats.md\", \"semcor.md\"]\nDepth = 2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"See all the github repository.","category":"page"}]
}
