<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>sem correlated · LogNormals.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LogNormals.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="lognormalprops.html">LogNormal properties</a></li><li><a class="tocitem" href="fitstats.html">Fit to statistic</a></li><li class="is-active"><a class="tocitem" href="semcor.html">sem correlated</a><ul class="internal"><li><a class="tocitem" href="#Effective-number-of-observations"><span>Effective number of observations</span></a></li><li><a class="tocitem" href="#Standard-error-of-the-mean-of-a-correlated-series"><span>Standard error of the mean of a correlated series</span></a></li><li><a class="tocitem" href="#Variance-of-a-correlated-series"><span>Variance of a correlated series</span></a></li><li><a class="tocitem" href="#Effective-autocorrelation-function"><span>Effective autocorrelation function</span></a></li><li><a class="tocitem" href="#Autocorrelation-of-a-series-with-missing-values"><span>Autocorrelation of a series with missing values</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="semcor.html">sem correlated</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="semcor.html">sem correlated</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bgctw/LogNormals.jl/blob/master/docs/src/semcor.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Standard-error-of-the-mean-of-correlated-series"><a class="docs-heading-anchor" href="#Standard-error-of-the-mean-of-correlated-series">Standard error of the mean of correlated series</a><a id="Standard-error-of-the-mean-of-correlated-series-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-error-of-the-mean-of-correlated-series" title="Permalink"></a></h1><p>The standard error of the mean of a series with positive autocorrelation is larger than  for an uncorrelated series, because the variance  <a href="https://en.wikipedia.org/wiki/Variance#Sum_of_correlated_variables">includes positive covariance terms</a>  in addition to the variance of each record.</p><h2 id="Effective-number-of-observations"><a class="docs-heading-anchor" href="#Effective-number-of-observations">Effective number of observations</a><a id="Effective-number-of-observations-1"></a><a class="docs-heading-anchor-permalink" href="#Effective-number-of-observations" title="Permalink"></a></h2><p>For uncorrelated series, the variance of the mean decreases by the number of records compared to the  variance of a single record.</p><p class="math-container">\[Var(\bar{x}) = {Var(x) \over n}\]</p><p>For correlated series, the effective number of observations is defined as to give the same scaling.</p><p class="math-container">\[Var(\bar{x}) = {Var(x) \over n_{eff}}\]</p><p>There are only <span>$n_{eff}$</span> number of effective obserservations in the series.</p><article class="docstring"><header><a class="docstring-binding" id="LogNormals.effective_n_cor" href="#LogNormals.effective_n_cor"><code>LogNormals.effective_n_cor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">effective_n_cor(x, ms::MissingStrategy=PassMissing()) 
effective_n_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())</code></pre><p>Compute the number of effective observations for an autocorrelated series.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: An iterator of a series of observations.</li><li><code>ms</code>: <code>MissingStrategy</code>: If not given defaults to <code>PassMissing</code>.  Set to <code>ExactMissing()</code> to consciouly handle missing value in <code>x</code>.</li><li><code>acf</code>: AutocorrelationFunction starting from lag 0.   If not given, defaults to <code>autocor(x, ms)</code> </li></ul><p>The formula in Zieba has been extended for missing values:</p><p class="math-container">\[n_{eff} = \frac{n_F}{1+{2 \over n_F} \sum_{k=1}^{min(n-1,n_k)} (n-k-m_k) \rho_k}\]</p><p>where <span>$n$</span> is the number of total records, <span>$n_F$</span> is the number of  finite records, <span>$n_k$</span> is the nummber of components in the  used autocorrelation function (<span>$n-1$</span> if not estimated from the data) ,<span>$\rho_k$</span> is the correlation, and  <span>$m_k$</span> is the number of pairs that contain a missing value for lag <span>$k$</span>.</p><p><strong>Details</strong></p><p>Missing values are not handled by default, i.e. the number of effective observations is missing if ther any missings in <code>x</code>.  The recommended way is using <code>ExactMissing()</code>.  Alternatively, se to  <code>SkipMissing()</code> to speed up computation  (by internally omitting <a href="semcor.html#LogNormals.count_forlags"><code>count_forlags</code></a> missing pairs)  at the cost of a positively biased result with increasing bias with the number of missings.  The latter leads to a subsequent underestimated uncertainty of the sum or the mean.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Distributions, DistributionVectors, Missings, MissingStrategies, LinearAlgebra
acf0 = [1,0.4,0.1]
Sigma = cormatrix_for_acf(100, acf0);
# 100 random variables each Normal(1,1)
dmn = MvNormal(ones(100), Symmetric(Sigma));
x = allowmissing(rand(dmn));    
x[11:20] .= missing
neff = effective_n_cor(x, acf0, ExactMissing())
neff &lt; 90
neff_biased = effective_n_cor(x, acf0, SkipMissing())
neff_biased &gt; neff</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L338-L387">source</a></section><section><div><pre><code class="language-julia">effective_n_cor(x, ms::MissingStrategy=PassMissing()) 
effective_n_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())</code></pre><p>Compute the number of effective observations for an autocorrelated series.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: An iterator of a series of observations.</li><li><code>ms</code>: <code>MissingStrategy</code>: If not given defaults to <code>PassMissing</code>.  Set to <code>ExactMissing()</code> to consciouly handle missing value in <code>x</code>.</li><li><code>acf</code>: AutocorrelationFunction starting from lag 0.   If not given, defaults to <code>autocor(x, ms)</code> </li></ul><p>The formula in Zieba has been extended for missing values:</p><p class="math-container">\[n_{eff} = \frac{n_F}{1+{2 \over n_F} \sum_{k=1}^{min(n-1,n_k)} (n-k-m_k) \rho_k}\]</p><p>where <span>$n$</span> is the number of total records, <span>$n_F$</span> is the number of  finite records, <span>$n_k$</span> is the nummber of components in the  used autocorrelation function (<span>$n-1$</span> if not estimated from the data) ,<span>$\rho_k$</span> is the correlation, and  <span>$m_k$</span> is the number of pairs that contain a missing value for lag <span>$k$</span>.</p><p><strong>Details</strong></p><p>Missing values are not handled by default, i.e. the number of effective observations is missing if ther any missings in <code>x</code>.  The recommended way is using <code>ExactMissing()</code>.  Alternatively, se to  <code>SkipMissing()</code> to speed up computation  (by internally omitting <a href="semcor.html#LogNormals.count_forlags"><code>count_forlags</code></a> missing pairs)  at the cost of a positively biased result with increasing bias with the number of missings.  The latter leads to a subsequent underestimated uncertainty of the sum or the mean.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Distributions, DistributionVectors, Missings, MissingStrategies, LinearAlgebra
acf0 = [1,0.4,0.1]
Sigma = cormatrix_for_acf(100, acf0);
# 100 random variables each Normal(1,1)
dmn = MvNormal(ones(100), Symmetric(Sigma));
x = allowmissing(rand(dmn));    
x[11:20] .= missing
neff = effective_n_cor(x, acf0, ExactMissing())
neff &lt; 90
neff_biased = effective_n_cor(x, acf0, SkipMissing())
neff_biased &gt; neff</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L338-L387">source</a></section><section><div><pre><code class="language-julia">effective_n_cor(x, ms::MissingStrategy=PassMissing()) 
effective_n_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())</code></pre><p>Compute the number of effective observations for an autocorrelated series.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: An iterator of a series of observations.</li><li><code>ms</code>: <code>MissingStrategy</code>: If not given defaults to <code>PassMissing</code>.  Set to <code>ExactMissing()</code> to consciouly handle missing value in <code>x</code>.</li><li><code>acf</code>: AutocorrelationFunction starting from lag 0.   If not given, defaults to <code>autocor(x, ms)</code> </li></ul><p>The formula in Zieba has been extended for missing values:</p><p class="math-container">\[n_{eff} = \frac{n_F}{1+{2 \over n_F} \sum_{k=1}^{min(n-1,n_k)} (n-k-m_k) \rho_k}\]</p><p>where <span>$n$</span> is the number of total records, <span>$n_F$</span> is the number of  finite records, <span>$n_k$</span> is the nummber of components in the  used autocorrelation function (<span>$n-1$</span> if not estimated from the data) ,<span>$\rho_k$</span> is the correlation, and  <span>$m_k$</span> is the number of pairs that contain a missing value for lag <span>$k$</span>.</p><p><strong>Details</strong></p><p>Missing values are not handled by default, i.e. the number of effective observations is missing if ther any missings in <code>x</code>.  The recommended way is using <code>ExactMissing()</code>.  Alternatively, se to  <code>SkipMissing()</code> to speed up computation  (by internally omitting <a href="semcor.html#LogNormals.count_forlags"><code>count_forlags</code></a> missing pairs)  at the cost of a positively biased result with increasing bias with the number of missings.  The latter leads to a subsequent underestimated uncertainty of the sum or the mean.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Distributions, DistributionVectors, Missings, MissingStrategies, LinearAlgebra
acf0 = [1,0.4,0.1]
Sigma = cormatrix_for_acf(100, acf0);
# 100 random variables each Normal(1,1)
dmn = MvNormal(ones(100), Symmetric(Sigma));
x = allowmissing(rand(dmn));    
x[11:20] .= missing
neff = effective_n_cor(x, acf0, ExactMissing())
neff &lt; 90
neff_biased = effective_n_cor(x, acf0, SkipMissing())
neff_biased &gt; neff</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L338-L387">source</a></section></article><h2 id="Standard-error-of-the-mean-of-a-correlated-series"><a class="docs-heading-anchor" href="#Standard-error-of-the-mean-of-a-correlated-series">Standard error of the mean of a correlated series</a><a id="Standard-error-of-the-mean-of-a-correlated-series-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-error-of-the-mean-of-a-correlated-series" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LogNormals.sem_cor" href="#LogNormals.sem_cor"><code>LogNormals.sem_cor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sem_cor(x, ms::MissingStrategy=PassMissing())
sem_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())</code></pre><p>Estimate the standard error of the mean of an autocorrelated series: <span>$Var(\bar{x}) = {Var(x) \over n_{eff}}$</span>.    </p><p><strong>Arguments</strong></p><ul><li><code>x</code>: An iterator of a series of observations</li><li><code>acf</code>: AutocorrelationFunction starting from lag 0. </li><li><code>ms</code>: <code>MissingStrategy</code> passed to <a href="semcor.html#LogNormals.effective_n_cor"><code>effective_n_cor</code></a>. Value of <code>SkipMissing()</code> speeds up computation compared to <code>ExactMissing()</code>, but leads to a negatively biased result with absolute value of the bias  increasing with the number of missings.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>neff</code>: may provide a precomputed number of observations for efficiency.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L250-L267">source</a></section><section><div><pre><code class="language-julia">sem_cor(x, ms::MissingStrategy=PassMissing())
sem_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())</code></pre><p>Estimate the standard error of the mean of an autocorrelated series: <span>$Var(\bar{x}) = {Var(x) \over n_{eff}}$</span>.    </p><p><strong>Arguments</strong></p><ul><li><code>x</code>: An iterator of a series of observations</li><li><code>acf</code>: AutocorrelationFunction starting from lag 0. </li><li><code>ms</code>: <code>MissingStrategy</code> passed to <a href="semcor.html#LogNormals.effective_n_cor"><code>effective_n_cor</code></a>. Value of <code>SkipMissing()</code> speeds up computation compared to <code>ExactMissing()</code>, but leads to a negatively biased result with absolute value of the bias  increasing with the number of missings.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>neff</code>: may provide a precomputed number of observations for efficiency.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L250-L267">source</a></section></article><p>The default estiamtes the empirical autocorrelation from the given series.  If possible, use a more precise estimate from longer series. For example when computing the daily means of an hourly time series, estimate the  empirical autocorrelation from monthly or annual series and provide it to the daily applications of <code>sem_cor</code> using argument <code>acfe</code>.</p><h2 id="Variance-of-a-correlated-series"><a class="docs-heading-anchor" href="#Variance-of-a-correlated-series">Variance of a correlated series</a><a id="Variance-of-a-correlated-series-1"></a><a class="docs-heading-anchor-permalink" href="#Variance-of-a-correlated-series" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LogNormals.var_cor" href="#LogNormals.var_cor"><code>LogNormals.var_cor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">var_cor(x, ms::MissingStrategy=PassMissing())
var_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())</code></pre><p>Estimate the variance for an autocorrelated series.</p><p>Zieba 2011 provide the following formula:</p><p class="math-container">\[Var(x) = \frac{n_{eff}}{n (n_{eff}-1)} \sum \left( x_i - \bar{x} \right)^2 
= {(n-1) n_{eff} \over n (n_{eff}-1)} Var_{uncor}(x)\]</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: An iterator of a series of observations</li><li><code>acf</code>: AutocorrelationFunction starting from lag 0. </li><li><code>ms</code>: <code>MissingStrategy</code> passed to <a href="semcor.html#LogNormals.effective_n_cor"><code>effective_n_cor</code></a>. Value of <code>SkipMissing()</code> speeds up computation compared to <code>ExactMissing()</code>, but leads to a negatively biased result with absolute value of the bias  increasing with the number of missings.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>neff</code>: may provide a precomputed number of observations for efficiency.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L279-L301">source</a></section><section><div><pre><code class="language-julia">var_cor(x, ms::MissingStrategy=PassMissing())
var_cor(x, acf::AbstractVector, ms::MissingStrategy=PassMissing())</code></pre><p>Estimate the variance for an autocorrelated series.</p><p>Zieba 2011 provide the following formula:</p><p class="math-container">\[Var(x) = \frac{n_{eff}}{n (n_{eff}-1)} \sum \left( x_i - \bar{x} \right)^2 
= {(n-1) n_{eff} \over n (n_{eff}-1)} Var_{uncor}(x)\]</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: An iterator of a series of observations</li><li><code>acf</code>: AutocorrelationFunction starting from lag 0. </li><li><code>ms</code>: <code>MissingStrategy</code> passed to <a href="semcor.html#LogNormals.effective_n_cor"><code>effective_n_cor</code></a>. Value of <code>SkipMissing()</code> speeds up computation compared to <code>ExactMissing()</code>, but leads to a negatively biased result with absolute value of the bias  increasing with the number of missings.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>neff</code>: may provide a precomputed number of observations for efficiency.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L279-L301">source</a></section></article><h2 id="Effective-autocorrelation-function"><a class="docs-heading-anchor" href="#Effective-autocorrelation-function">Effective autocorrelation function</a><a id="Effective-autocorrelation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Effective-autocorrelation-function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LogNormals.autocor_effective" href="#LogNormals.autocor_effective"><code>LogNormals.autocor_effective</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">autocor_effective(x, ms::MissingStrategy=PassMissing())
autocor_effective(x, acf)</code></pre><p>Estimate the effective autocorrelation function for series x.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: An iterator of a series of observations</li><li><code>ms</code>: <code>MissingStrategy</code> passed to <a href="semcor.html#StatsBase.autocor"><code>autocor</code></a></li><li><code>acf</code>: AutocorrelationFunction starting from lag 0</li></ul><p><strong>Notes</strong></p><ul><li>The effect autocorrelation function   are the first coefficients of the autocorrelation function up to  before the first negative coefficient. </li><li>According to Zieba 2011 using this effective version rather the full version when estimating the autocorrelationfunction from the data yields better result for the standard error of the mean (<a href="semcor.html#LogNormals.sem_cor"><code>sem_cor</code></a>).</li><li>Optional argument <code>acf</code> allows the caller to provide a precomputed estimate of autocorrelation function (see <a href="semcor.html#StatsBase.autocor"><code>autocor</code></a>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L217-L237">source</a></section><section><div><pre><code class="language-julia">autocor_effective(x, ms::MissingStrategy=PassMissing())
autocor_effective(x, acf)</code></pre><p>Estimate the effective autocorrelation function for series x.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: An iterator of a series of observations</li><li><code>ms</code>: <code>MissingStrategy</code> passed to <a href="semcor.html#StatsBase.autocor"><code>autocor</code></a></li><li><code>acf</code>: AutocorrelationFunction starting from lag 0</li></ul><p><strong>Notes</strong></p><ul><li>The effect autocorrelation function   are the first coefficients of the autocorrelation function up to  before the first negative coefficient. </li><li>According to Zieba 2011 using this effective version rather the full version when estimating the autocorrelationfunction from the data yields better result for the standard error of the mean (<a href="semcor.html#LogNormals.sem_cor"><code>sem_cor</code></a>).</li><li>Optional argument <code>acf</code> allows the caller to provide a precomputed estimate of autocorrelation function (see <a href="semcor.html#StatsBase.autocor"><code>autocor</code></a>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L217-L237">source</a></section></article><h2 id="Autocorrelation-of-a-series-with-missing-values"><a class="docs-heading-anchor" href="#Autocorrelation-of-a-series-with-missing-values">Autocorrelation of a series with missing values</a><a id="Autocorrelation-of-a-series-with-missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Autocorrelation-of-a-series-with-missing-values" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsBase.autocor" href="#StatsBase.autocor"><code>StatsBase.autocor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">autocor(x::AbstractVector{x::&lt;:Union{Missing,Real}, ms::MissingStrategy=PassMissing(); 
    dmean::Bool=true}
autocor(x::AbstractVector{x::&lt;:Union{Missing,Real}, lags, ms::MissingStrategy=PassMissing(); 
    dmean::Bool=true}
autocor(x::AbstractMatrix{x::&lt;:Union{Missing,Real}, ms::MissingStrategy=PassMissing(); 
    dmean::Bool=true}
autocor(x::AbstractMatrix{x::&lt;:Union{Missing,Real}, lags, ms::MissingStrategy=PassMissing(); 
    dmean::Bool=true}</code></pre><p>Estimate the autocorrelation function accounting for missing values.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: series or matrix with series in columns, which may contain missing values</li><li><code>lags</code>: Integer vector of the lags for which correlation should be computed</li><li><code>ms</code>: <code>MissingStrategy</code>. Defaults to <code>PassMissing</code>. Set to <code>ExactMissing()</code> to   divide the sum  in the formula of the exepected value in the formula for the correlation  at lag <code>k</code> by <code>n - nmissing</code> instead of <code>n</code>,   where <code>nimissing</code> is the number of records where there is a missing either  in the original vector or its lagged version (see <a href="semcor.html#LogNormals.count_forlags"><code>count_forlags</code></a>).</li><li><code>deman</code>: if <code>false</code>, assume <code>mean(x)==0</code>.</li></ul><p>If the missing strategy is set to <code>SkipMissing()</code> then the computation is faster,  but it is more strongly biased low with increasing number of missings.  Note that <code>StatsBase.autocor</code> uses devision by <code>n</code> instead of &#39;n-k&#39;, the true length of the vectors correlated at lag <code>k</code> resulting in  low-biased correlations of higher lags for numerical stability reasons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L48-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LogNormals.count_forlags" href="#LogNormals.count_forlags"><code>LogNormals.count_forlags</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">count_forlags(pred, x, lags)
count_forlag(pred, x, k::Integer)</code></pre><p>Count the number of pairs for lag <code>k</code> which fulfil a predicate.</p><p><strong>Arguments</strong></p><ul><li><code>pred::Function(x_i,x_iplusk)::Bool</code>: The predicate to be applied to each pair </li><li><code>x</code>: The series whose lags are inspected.</li><li><code>lags</code>: An iterator of Integer lag sizes</li><li><code>k</code>: A single lag.</li></ul><p>Common case is to compute the number of missings for the autocorrelation: with predicate <code>missinginpair(x,y) = ismissing(x) || ismissing(y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bgctw/LogNormals.jl/blob/4eef8d35a107645f9393b4f3de478a560671e813/src/semcor.jl#L1-L15">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="fitstats.html">« Fit to statistic</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 29 March 2021 09:49">Monday 29 March 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
